}
return(result)
}
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Random selection among eligible sources
opt2 <- smart_merge_three(a, b, c, prefer = "random", mode = "smart")
# Round-robin cycling, avoiding immediate repeats
opt3 <- smart_merge_three(a, b, c, mode = "roundrobin")
smart_merge_three <- function(list1, list2, list3) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
total_len <- length(list1) + length(list2) + length(list3)
for (k in 1:total_len) {
# Find which sources still have elements left and are not the last used
candidates <- which(indices <= sapply(sources, length) & seq_along(sources) != last_used)
if (length(candidates) == 0) {
# If no alternative, have to repeat the last one
candidates <- which(indices <= sapply(sources, length))
}
# Choose the candidate with the most remaining elements
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c)
print(merged)
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
# opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Random selection among eligible sources
opt2 <- smart_merge_three(a, b, c, prefer = "random", mode = "smart")
View(opt2)
smart_merge_three <- function(list1, list2, list3, prefer = "longest", mode = "smart") {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
# opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Random selection among eligible sources
opt2 <- smart_merge_three(a, b, c, prefer = "random", mode = "smart")
smart_merge_three <- function(list1, list2, list3, strict = TRUE) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
usage_counts <- c(0, 0, 0)
result <- list()
last_used <- NA
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
candidates <- setdiff(available, last_used)
if (length(candidates) == 0) {
candidates <- available  # fallback to any if only one left
}
if (strict) {
# Choose the candidate used the least so far
min_use <- min(usage_counts[candidates])
candidates <- candidates[usage_counts[candidates] == min_use]
}
# Random tie-breaker among eligible candidates
chosen <- sample(candidates, 1)
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
usage_counts[chosen] <- usage_counts[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3", "a4")
b <- list("b1", "b2", "b3")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c, strict = TRUE)
smart_merge_three <- function(list1, list2, list3, strict = TRUE) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
usage_counts <- c(0, 0, 0)
result <- list()
last_used <- NA
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
candidates <- setdiff(available, last_used)
if (length(candidates) == 0) {
candidates <- available  # fallback to any if only one left
}
if (strict) {
# Choose the candidate used the least so far
min_use <- min(usage_counts[candidates])
candidates <- candidates[usage_counts[candidates] == min_use]
}
# Random tie-breaker among eligible candidates
chosen <- sample(candidates, 1)
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
usage_counts[chosen] <- usage_counts[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3", "a4")
b <- list("b1", "b2", "b3")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c, strict = TRUE)
print(merged)
smart_merge_three <- function(list1, list2, list3, strict = TRUE) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
usage_counts <- c(0, 0, 0)
result <- list()
last_used <- NA
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
candidates <- setdiff(available, last_used)
if (length(candidates) == 0) {
candidates <- available  # fallback to any if only one left
}
if (strict) {
# Choose the candidate used the least so far
min_use <- min(usage_counts[candidates])
candidates <- candidates[usage_counts[candidates] == min_use]
}
# Random tie-breaker among eligible candidates
chosen <- sample(candidates, 1)
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
usage_counts[chosen] <- usage_counts[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9","a10",
"a11","a12","a13","a14","a15","a16")
b <- list("b1", "b2")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c, strict = TRUE)
View(merged)
merge_three_with_constraints <- function(list1, list2, list3) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA  # 1 = list1, 2 = list2, 3 = list3
total_len <- sum(sapply(sources, length))
for (i in 1:total_len) {
available <- which(indices <= sapply(sources, length))
# Filter based on constraints:
# Avoid using list2 (2) or list3 (3) if they were just used
candidates <- available
if (last_used == 2) {
candidates <- setdiff(candidates, 2)
}
if (last_used == 3) {
candidates <- setdiff(candidates, 3)
}
# If list2 or list3 are available and not just used, prefer them
if (2 %in% candidates) {
chosen <- 2
} else if (3 %in% candidates) {
chosen <- 3
} else if (1 %in% candidates) {
chosen <- 1
} else {
# fallback: allow breaking the constraint if only one option remains
chosen <- available[1]
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
list1 <- as.list(1:10)
list2 <- list("A", "B", "C")
list3 <- list("X", "Y")
merged <- merge_three_with_constraints(list1, list2, list3)
merge_with_constraints_prefer_list1 <- function(list1, list2, list3) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA  # 1 = list1, 2 = list2, 3 = list3
total_len <- sum(sapply(sources, length))
for (i in 1:total_len) {
available <- which(indices <= sapply(sources, length))
# Enforce constraints: avoid consecutive use of list2 or list3
if (last_used == 2) {
available <- setdiff(available, 2)
}
if (last_used == 3) {
available <- setdiff(available, 3)
}
# Prefer list1 if available
if (1 %in% available) {
chosen <- 1
} else if (2 %in% available) {
chosen <- 2
} else if (3 %in% available) {
chosen <- 3
} else {
# fallback if nothing else available (even if repeating)
fallback <- which(indices <= sapply(sources, length))
chosen <- fallback[1]
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
list1 <- as.list(1:15)
list2 <- list("A", "B", "C", "D")
list3 <- list("X", "Y")
merged <- merge_with_constraints_prefer_list1(list1, list2, list3)
rm(list = ls(all.names = TRUE))
# -----------------------------------------------------------------------------
# Load packages.
# -----------------------------------------------------------------------------
library(dplyr)
library(tidyverse)
library(readxl)
library(data.table)
library(writexl) # We use this package for writing for compatibility
# -----------------------------------------------------------------------------
# Set the directories.
# -----------------------------------------------------------------------------
dirs <- list()
dirs$main <- ("C:/Users/User/MATLAB/TypiTarget/")
# Directory where to find the image files of target and non target category
dirs$images <- paste(dirs$main, "/stimuli_target", sep="")
image_list <- list.files(path = dirs$images, recursive = TRUE, pattern = "\\.jpg$", full.names = TRUE)
df_image <- data.frame()
desired_order <- c("category",
"stimulus",
"conceptual",
"perceptual",
"rt", "n",
"typicality",
"p_typicality",
"p_conceptual",
"p_perceptual")
desired_order
df_image.columns = desired_order
df_image
df_imag$category
df_image$category
df_image$category = image_list
df_image$category <- image_list
df_image <- data.frame(columns = desired_order)
del df_image.columns
remove(df_image.columns)
df_image.columns
View(df_image)
df_image <- data.frame()
colnames(df_image) <- desired_order
df_image <- data.frame()
colnames(df_image) <- desired_order
setNames(data.frame(matrix(ncol = 10, nrow = 0)), desired_order)
View(df_image)
df_image <- data.frame(matrix(ncol = 10, nrow = 0))
colnames(df_image) <- desired_order
View(df_image)
df_image.columns
df_image.columns(9)
df_image.columns()
df_image$category <- 'target'
df_image$stimulus <- image_list
df_image <- data.frame(matrix(ncol = 10, nrow = length(image_list)))
colnames(df_image) <- desired_order
df_image$category <- 'target'
df_image$stimulus <- image_list
View(df_image)
df_image$stimulus <- gsub("^.*/", "", df_image$stimulus)
df_image_target <- as_tibble(data.frame(matrix(ncol = 10, nrow = length(image_list_target))))
image_list_target    <- list.files(path = dirs$images_target, recursive = TRUE, pattern = "\\.jpg$", full.names = TRUE)
# Directory where to find the image files of target and non target category
dirs$images_target <- paste(dirs$main, "/stimuli_target", sep="")
dirs$images_nontarget <- paste(dirs$main, "/stimuli_nontarget", sep="")
image_list_target    <- list.files(path = dirs$images_target, recursive = TRUE, pattern = "\\.jpg$", full.names = TRUE)
image_list_nontarget <- list.files(path = dirs$images_nontarget, recursive = TRUE, pattern = "\\.jpg$", full.names = TRUE)
df_image_target <- data.frame(matrix(ncol = 10, nrow = length(image_list_target)))
df_image_target <- tibble(df_image_target)
colnames(df_image_target) <- desired_order
df_image$stimulus <- image_list
df_image$stimulus <- gsub("^.*/", "", df_image$stimulus)
df_image$category <- 'target'
View(df_image_target)
View(df_image_target)
colnames(df_image_target) <- desired_order
df_image_target <- df_image_target
df_image_target <- data.frame(matrix(ncol = 10, nrow = length(image_list_target)))
colnames(df_image_target) <- desired_order
as_tibble(df_image_target)
df_image_target <- data.frame(matrix(ncol = 10, nrow = length(image_list_target)))
colnames(df_image_target) <- desired_order
View(df_image_target)
df_image_target <- as_tibble(df_image_target)
View(df_image_target)
df_image$stimulus <- image_list
View(df_image_target)
df_image$stimulus <- image_list
View(df_image_target)
df_image_target <- data.frame(matrix(ncol = 10, nrow = length(image_list_target)))
colnames(df_image_target) <- desired_order
View(df_image_target)
View(df_image_target)
df_image$stimulus <- image_list
View(df_image_target)
df_image$stimulus <- image_list_target
View(df_image_target)
df_image_target$stimulus <- image_list_target
View(df_image_target)
df_image_target <- data.frame(matrix(ncol = 10, nrow = length(image_list_target)))
colnames(df_image_target) <- desired_order
df_image_target <- as_tibble(df_image_target)
df_image_target$stimulus <- image_list_target
View(df_image_target)
df_image_target$stimulus <- gsub("^.*/", "", df_image$stimulus)
df_image_target$category <- 'target'
df_image_target <- df_image %>% complete(fill = list(typicality = 0))
df_image_target <- df_image_target %>% complete(fill = list(typicality = 0))
df_image_target <- df_image_target %>% replace_na(0)
df_image_target <- df_image_target %>% replace_na(list(0))
df_image_target <- data.frame(matrix(ncol = 10, nrow = length(image_list_target)))
colnames(df_image_target) <- desired_order
df_image_target <- as_tibble(df_image_target)
df_image_target$stimulus <- image_list_target
df_image_target$stimulus <- gsub("^.*/", "", df_image$stimulus)
df_image_target$category <- 'target'
df_image_target <- df_image_target %>% replace_na(list(0))
df_image_target <- df_image_target %>% replace(is.na(.), 0) #replace_na(list(0))
View(df_image)
df_image_nontarget <- data.frame(matrix(ncol = 10, nrow = length(image_list_nontarget)))
colnames(df_image_nontarget) <- desired_order
df_image_nontarget <- as_tibble(df_image_nontarget)
df_image_nontarget$stimulus <- image_list_nontarget
df_image_nontarget$stimulus <- gsub("^.*/", "", df_image_nontarget$stimulus)
df_image_nontarget$category <- 'nontarget'
df_image_nontarget <- df_image_nontarget %>% replace(is.na(.), 0)
View(df_image_nontarget)
# write data tables as excel files
write_xlsx(df_image_target, "stim_info_target.xlsx", col_names = TRUE)
write_xlsx(df_image_nontarget, "stim_info_nontarget.xlsx", col_names = TRUE)
