x <- 1:12
sample(x)
sample(x, replace = TRUE)
sample(c(0,1), 100, replace = TRUE)
resample <- function(x,...)x[sample.int(length(x),...)]
resample(x[x>8])
resample(x[x>9])
resample(x[x>10])
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer = "longest", mode = "smart") {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer = "longest", mode = "smart") {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Random selection among eligible sources
opt2 <- smart_merge_three(a, b, c, prefer = "random", mode = "smart")
# Round-robin cycling, avoiding immediate repeats
opt3 <- smart_merge_three(a, b, c, mode = "roundrobin")
smart_merge_three <- function(list1, list2, list3) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
total_len <- length(list1) + length(list2) + length(list3)
for (k in 1:total_len) {
# Find which sources still have elements left and are not the last used
candidates <- which(indices <= sapply(sources, length) & seq_along(sources) != last_used)
if (length(candidates) == 0) {
# If no alternative, have to repeat the last one
candidates <- which(indices <= sapply(sources, length))
}
# Choose the candidate with the most remaining elements
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c)
print(merged)
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
smart_merge_three <- function(list1, list2, list3, prefer, mode) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
# opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Random selection among eligible sources
opt2 <- smart_merge_three(a, b, c, prefer = "random", mode = "smart")
View(opt2)
smart_merge_three <- function(list1, list2, list3, prefer = "longest", mode = "smart") {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA
current_rr <- 1  # for round-robin
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
if (mode == "roundrobin") {
# Round-robin mode: find next available index not equal to last_used
tries <- 0
repeat {
if (tries > length(sources)) break  # fallback
current_rr <- (current_rr %% length(sources)) + 1
if (current_rr %in% available && current_rr != last_used) break
tries <- tries + 1
}
chosen <- current_rr
} else {
# Smart mode
candidates <- available[available != last_used]
if (length(candidates) == 0) {
candidates <- available  # fallback if only last_used is left
}
if (prefer == "random") {
chosen <- sample(candidates, 1)
} else {  # prefer = "longest"
remaining_counts <- sapply(candidates, function(i) length(sources[[i]]) - indices[i] + 1)
chosen <- candidates[which.max(remaining_counts)]
}
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3")
b <- list("b1", "b2", "b3", "b4")
c <- list("c1", "c2")
# Prefer longest, smart scheduling
# opt1 <- smart_merge_three(a, b, c, prefer = "longest", mode = "smart")
# Random selection among eligible sources
opt2 <- smart_merge_three(a, b, c, prefer = "random", mode = "smart")
smart_merge_three <- function(list1, list2, list3, strict = TRUE) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
usage_counts <- c(0, 0, 0)
result <- list()
last_used <- NA
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
candidates <- setdiff(available, last_used)
if (length(candidates) == 0) {
candidates <- available  # fallback to any if only one left
}
if (strict) {
# Choose the candidate used the least so far
min_use <- min(usage_counts[candidates])
candidates <- candidates[usage_counts[candidates] == min_use]
}
# Random tie-breaker among eligible candidates
chosen <- sample(candidates, 1)
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
usage_counts[chosen] <- usage_counts[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3", "a4")
b <- list("b1", "b2", "b3")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c, strict = TRUE)
smart_merge_three <- function(list1, list2, list3, strict = TRUE) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
usage_counts <- c(0, 0, 0)
result <- list()
last_used <- NA
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
candidates <- setdiff(available, last_used)
if (length(candidates) == 0) {
candidates <- available  # fallback to any if only one left
}
if (strict) {
# Choose the candidate used the least so far
min_use <- min(usage_counts[candidates])
candidates <- candidates[usage_counts[candidates] == min_use]
}
# Random tie-breaker among eligible candidates
chosen <- sample(candidates, 1)
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
usage_counts[chosen] <- usage_counts[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3", "a4")
b <- list("b1", "b2", "b3")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c, strict = TRUE)
print(merged)
smart_merge_three <- function(list1, list2, list3, strict = TRUE) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
usage_counts <- c(0, 0, 0)
result <- list()
last_used <- NA
total_len <- sum(sapply(sources, length))
for (k in 1:total_len) {
available <- which(indices <= sapply(sources, length))
candidates <- setdiff(available, last_used)
if (length(candidates) == 0) {
candidates <- available  # fallback to any if only one left
}
if (strict) {
# Choose the candidate used the least so far
min_use <- min(usage_counts[candidates])
candidates <- candidates[usage_counts[candidates] == min_use]
}
# Random tie-breaker among eligible candidates
chosen <- sample(candidates, 1)
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
usage_counts[chosen] <- usage_counts[chosen] + 1
last_used <- chosen
}
return(result)
}
a <- list("a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9","a10",
"a11","a12","a13","a14","a15","a16")
b <- list("b1", "b2")
c <- list("c1", "c2")
merged <- smart_merge_three(a, b, c, strict = TRUE)
View(merged)
merge_three_with_constraints <- function(list1, list2, list3) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA  # 1 = list1, 2 = list2, 3 = list3
total_len <- sum(sapply(sources, length))
for (i in 1:total_len) {
available <- which(indices <= sapply(sources, length))
# Filter based on constraints:
# Avoid using list2 (2) or list3 (3) if they were just used
candidates <- available
if (last_used == 2) {
candidates <- setdiff(candidates, 2)
}
if (last_used == 3) {
candidates <- setdiff(candidates, 3)
}
# If list2 or list3 are available and not just used, prefer them
if (2 %in% candidates) {
chosen <- 2
} else if (3 %in% candidates) {
chosen <- 3
} else if (1 %in% candidates) {
chosen <- 1
} else {
# fallback: allow breaking the constraint if only one option remains
chosen <- available[1]
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
list1 <- as.list(1:10)
list2 <- list("A", "B", "C")
list3 <- list("X", "Y")
merged <- merge_three_with_constraints(list1, list2, list3)
merge_with_constraints_prefer_list1 <- function(list1, list2, list3) {
sources <- list(list1, list2, list3)
indices <- c(1, 1, 1)
result <- list()
last_used <- NA  # 1 = list1, 2 = list2, 3 = list3
total_len <- sum(sapply(sources, length))
for (i in 1:total_len) {
available <- which(indices <= sapply(sources, length))
# Enforce constraints: avoid consecutive use of list2 or list3
if (last_used == 2) {
available <- setdiff(available, 2)
}
if (last_used == 3) {
available <- setdiff(available, 3)
}
# Prefer list1 if available
if (1 %in% available) {
chosen <- 1
} else if (2 %in% available) {
chosen <- 2
} else if (3 %in% available) {
chosen <- 3
} else {
# fallback if nothing else available (even if repeating)
fallback <- which(indices <= sapply(sources, length))
chosen <- fallback[1]
}
result <- c(result, sources[[chosen]][[indices[chosen]]])
indices[chosen] <- indices[chosen] + 1
last_used <- chosen
}
return(result)
}
list1 <- as.list(1:15)
list2 <- list("A", "B", "C", "D")
list3 <- list("X", "Y")
merged <- merge_with_constraints_prefer_list1(list1, list2, list3)
